q
p ordered_collection.slice(0, @total.to_i).last
p ordered_collection.slice(0, @total.to_i).first
p ordered_collection.slice(0, @total.to_i).length
p ordered_collection.slice(0, @total.to_i - 1).length
p ordered_collection.slice(0, @total.to_ - 1).length
p ordered_collection.slice(0, @total - 1).length
p ordered_collection.first
p ordered_collection.last
q
p ordered_collection.last
p ordered_collection.first
c
p range.member?(item[:score])
p item[:score]
p range
q
p range.member?(item[:score])
p item[:score]
p range
q
n
p trait
n
c
p item[:traits]
p item
s
n
q
p @item["traits"]
p @item[:traits]
c
p item
s
n
q
p @collection
q
p @collection
q
p @collection.collection.first
p @collection.first
q
p @item[:traits]
p @item
q
p @item[:traits]
p @item
c
q
p range
p collection_in_range
p item
c
p @pick_range
q
p @pick_range.keys.count
p @pick_range
p range
q
p @pick_range.keys.count
8*step
p @pick_range
p range
q
range = minmax.first..minmax.last
p @pick_range.keys.count
p @pick_range.keys
p @pick_range.lenght
@distribution.length.to_f
minmax.last.to_f
(minmax.last.to_f / @distribution.length.to_f).to_i
minmax.first..minmax.last
@seed.values.map { |value| value[:score] }.minmax
p @pick_range
p range.member?(@seed.values.find { |v| v[:score] > 1147 }[:score])
p @seed.values.find { |v| v[:score] > 1147 }[:score]
p @seed.values.find { |v| v[:score] > 1147 }
p range.member?(@seed.values.find { |v| v[:score] > 1147 })
p collection_in_range
p range
p item
q
c
p range.member?(item[:score])
p range
p item[:score]
c
p item[:score]
p range
p range.member?(item[:score])
c
p range.member?(item[:score])
p item[:score]
p range
q
p range.member?(@seed.values.find { |v| v[:score] > 1147 })
p range.member?(@seed.values.find { |v| v[:score] })
p range.member?(@seed.values.find { |v| v[:score] > 1147 })
p @seed.values.select { |v| v[:score] > 1147 }
p @seed.values.any? { |v| v[:score] > 1147 }
p @seed.values.any { |v| v[:score] > 1147 }
p @seed.values.map { |v| v[:score] > 1147 }
p range
p @seed.values.map { |v| v[:score] }
p @seed.values.map(&:score)
p range
p item 
q
p item
c
p item
c
p item
q
p @seed.values.map(&:score)
p range
p collection_in_range
p item
q
p @winners
q
p item[:number] = tick
p item[:number]
p item
q
y
p collection_in_range
q
p collection_in_range.values.count
exit
p item
q
p item
c
n
q
p File.join(config_dir, "seed.json")
s
l=
p result[:seed]
q
p trait[:options]
p trait
q
p @traits.values
p trait
p trait["options"]
p trait[:options]
exit
*value
value
q
c
n
p curr_count
n
@traits[type]
n
q
p @traits[type]
q
p @traits[type]
c
p @traits
q
p @traits
p @traits[type]
c
n
c
p dir
q
p item
q
p @collection["collection"]
p @collection["seed"]
p @collection[:seed]
p @collection
p item["traits"]
p item[:traits]
p item
c
p File.join(@output_dir, "#{name}.png")
s
p @file_name
n
p trait_name
c
n
c
p @file_name
c
p @file_name
c
p @file_name
l=
p avatar
n
c
s
@avatar_traits
ordered_trait_names
n
s
 p @collection.length
s
n
c
n
s
p ordered_trait_names
n
s
p i
p item
s
p @collection
n
c
p File.join(dir, "christmas")
p File.join(dir, "christmas"))
c
p File.join(dir, "christmas")
p File.directory?(File.join(dir, "christmas"))
c
p FileUtils.ls dir
p dir
c
File.join("assets", "collection", "christmas.#{Time.now.to_i}")
c
exit
c
File.join("assets", "collection", "christmas.#{Time.now.to_i}")
c
p rejected
p accepted
p accpted
n
c
p accept_list
p accepted
n
c
p accepted
p rejected
n
p accept_list
p rejection_list
c
p accept_list
p traits
p rejection_list
c
p picker.pick
